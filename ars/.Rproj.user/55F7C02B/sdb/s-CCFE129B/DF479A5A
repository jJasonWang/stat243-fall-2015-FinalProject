{
    "contents" : "InitTk <- function(fun, fun_deriv, start, end){\n  xfunp <- function(x){\n    return(c(x, fun(x), fun_deriv(x)))\n  }\n\n  m <- 1\n  m.max <- 500\n  if ((start == -Inf) && (end == Inf)) {\n    while (1){\n      mat.temp <- xfunp(rnorm(1))\n      if (mat.temp[2] != -Inf){\n        break\n      }\n    }\n    mat.temp.pre <- mat.temp\n    if (mat.temp[3] < 0){\n      mat <- mat.temp\n      while (mat.temp[3] < 0 && m < m.max) {\n        mat.temp <- xfunp(mat.temp[1]-2^m)\n        if (mat.temp[3] < mat.temp.pre[3]){\n          stop(\"NOT Log-concave!!\")\n        } else {\n          mat <- rbind(mat, mat.temp)\n          mat.temp.pre <- mat.temp\n          m <- m + 1\n        }\n      }\n    } else if (mat.temp[3] > 0) {\n      mat <- mat.temp\n      while (mat.temp[3] > 0 && m < m.max) {\n        mat.temp <- xfunp(mat.temp[1]+2^m)\n        if (mat.temp[3] > mat.temp.pre[3]){\n          stop(\"NOT Log-concave!!\")\n        } else {\n          mat <- rbind(mat, mat.temp)\n          mat.temp.pre <- mat.temp\n          m <- m + 1\n        }\n      }\n    }\n  }  else if ((start == -Inf) && (end != Inf)) {\n    while (1){\n      mat.temp <- xfunp(end - rexp(1))\n      if (mat.temp[2] != -Inf){\n        break\n      }\n    }\n    mat <- mat.temp\n    mat.temp.pre <- mat.temp\n    while (mat.temp[3] < 0 && m < m.max) {\n      mat.temp <- xfunp(mat.temp[1]-2^m)\n      if (mat.temp[3] < mat.temp.pre[3]){\n        stop(\"NOT Log-concave!!\")\n      } else {\n        mat <- rbind(mat, mat.temp)\n        mat.temp.pre <- mat.temp\n        m <- m + 1\n      }\n    }\n  } else if ((start != -Inf) && (end == Inf)) {\n    while (1){\n      mat.temp <- xfunp(start + rexp(1))\n      if (mat.temp[2] != -Inf){\n        break\n      }\n    }\n    mat <- mat.temp\n    mat.temp.pre <- mat.temp\n    while (mat.temp[3] > 0 && m < m.max) {\n      mat.temp <- xfunp(mat.temp[1] + 2^m)\n      if (mat.temp[3] > mat.temp.pre[3]){\n        stop(\"NOT Log-concave!!\")\n      } else {\n        mat <- rbind(mat, mat.temp)\n        mat.temp.pre <- mat.temp\n        m <- m + 1\n      }\n    }\n  }  else {\n    a <- start + (end-start)/3\n    b <- end - (end-start)/3\n    mat <- rbind(xfunp(a), xfunp(b))\n  }\n  mat <- mat[order(mat[, 1]), ]\n  return(mat)\n}\n\ngenerate_u <- function(x, fun, fun_deriv, start, end){\n  k <- length(x)\n  z <- (fun(x[-1]) - fun(x[-k]) - x[-1]*fun_deriv(x[-1]) + x[-k]*fun_deriv(x[-k]))/(fun_deriv(x[-k]) - fun_deriv(x[-1]))\n\n  #Construct upper and lower bound\n  z <- c(start, z, end)\n\n  #Compute slope and intercept\n  a <- fun_deriv(x)\n  b <- fun(x) - a*x\n\n  out <- list(parameter=cbind(a, b), breaks=z)\n  out\n}\n\nsample_x <- function(mu, y){\n  ## calculate the list of areas ##\n  z <- mu$breaks\n  area <- rep(0, length(z)-1)\n  for (i in 1:length(area)){\n    # get parameters\n    a <- mu$parameter[i, 1]\n    b <- mu$parameter[i, 2]\n    # compute area\n    area[i] <- (exp(a*z[i+1]+b)-exp(a*z[i]+b))/a\n  }\n\n  ## determine which interval y falls in ##\n  chosen_area <- y*sum(area)\n  cum_area <- c(0,cumsum(area))\n  index <- findInterval(chosen_area,cum_area)\n  sub_area <- chosen_area-cum_area[index]\n\n  ## find the corresponding x values ##\n  x_star <- rep(0,length(y))\n  for (j in 1:length(index)){\n    i <- index[j]\n    a <- mu$parameter[i, 1]\n    b <- mu$parameter[i, 2]\n    z_star <- z[i]\n    area_star <- sub_area[j]\n    xx_star <- (log(a*area_star+exp(a*z_star+b))-b)/a\n    x_star[j] <- xx_star\n  }\n  return(x_star)\n}\n\neval_u <- function(x.temp, u){\n  # evalu: evaluate u(x) at temp.x\n  # Input:\n  #   temp.x, given x value\n  #   u, u function parameters\n  # Output:\n  #   u.val, u value at temp.x\n\n  # Check if temp.x is out of bounds.\n  if (x.temp < head(u$breaks,n=1) || x.temp > tail(u$breaks,n=1)){\n    stop(\"x.temp is out of bound.\")\n  }\n\n  ind <- sum(u$breaks <= x.temp)\n  u.val <- u$parameter[ind,1] * x.temp + u$parameter[ind,2]\n  return(as.numeric(u.val))\n}\n\neval_l <- function(x1, x, fun){\n  k <- length(x)\n\n  #Grouping\n  group <- cut(x1, breaks=x, labels=1:(k - 1))\n  #Check which group the x1 locate\n  xj <- x[as.numeric(group)]\n  xjplus <- x[as.numeric(group) + 1]\n\n  #Compute value\n  all <- ((xjplus - x1)*fun(xj) + (x1 - xj)*fun(xjplus))/(xjplus - xj)\n  all[is.na(all)] <- -Inf\n  return(all)\n}\n\nARS <- function(n, func, start=-Inf, end=Inf, fun_deriv=NULL, ...){\n  #####Need to do: check func is concave, normalize?#####\n\n  #Check if the input function\n  if(any(names(formals(func)) == \"log\")){\n    fun <- function(x){\n      func(x, ..., log=TRUE)\n    }\n  }else{\n    fun <- function(x){\n      log(func(x, ...))\n    }\n  }\n\n  #Get derivative function by Central difference\n  if(is.null(fun_deriv)){\n    h <- 1e-8\n    fun_deriv <- function(x){\n      (fun(x + h) - fun(x - h))/(2*h)\n    }\n  }\n\n  ######Question: sorted?#####\n  #Initial Value\n  mat <- InitTk(fun, fun_deriv, start, end)\n  Tk <- mat[1,]\n\n  #Set up\n  result <- rep(0, n)\n  size <- 1\n\n  #Generate u\n  uk <- generate_u(Tk, fun, fun_deriv, start, end)\n\n  #Matrix used for checking concavity\n  mat <- cbind(Tk, fun(Tk), fun_deriv(Tk))\n\n  while (size <= n){\n    #Sample from s(x)\n    y <- runif(1)\n    x.temp <- sample_x(uk, y)\n\n    #Compute upper and lower value\n    u.x <- eval_u(x.temp, uk)\n    l.x <- eval_l(x.temp, Tk, fun)\n\n    #Uniform random number to decide wether accept or reject\n    w=runif(1)\n    if(w <= exp(l.x - u.x)){\n      #Accept\n      result[size] <- x.temp\n      size <- size + 1\n    }else{\n      if(w <= exp(fun(x.temp) - u.x)){\n        #Accept\n        result[size] <- x.temp\n        size <- size + 1\n      }\n      #Reject, Update point\n      mat <- rbind(mat, c(x.temp, fun(x.temp), fun_deriv(x.temp)))\n      #Sort by Tk\n      mat <- mat[order(mat[, 1]), ]\n      Tk <- mat[, 1]\n\n      uk <- generate_u(Tk, fun, fun_deriv, start, end)\n      ##generate h.x and h.dev for checking concavity\n      ######check concavity#####\n      h.dev <- mat[,3]\n      if (all(diff(h.dev)<=0)==FALSE){\n        stop(\"Not log concave!\")\n      }\n    }\n  }\n  return(result)\n}\n\nARS(100, dnorm, sd=20)\n\n",
    "created" : 1449789275818.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "0|47|85|0|\n87|54|100|0|\n102|28|132|0|\n134|30|150|0|\n152|31|165|0|\n167|67|241|0|\n",
    "hash" : "3133655119",
    "id" : "DF479A5A",
    "lastKnownWriteTime" : 1449784526,
    "path" : "C:/Users/jason/Desktop/STAT 243/Homework/main2.R",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 5,
    "source_on_save" : false,
    "type" : "r_source"
}