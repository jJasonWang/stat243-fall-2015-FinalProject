size <- 1
#Generate u
uk <- generate_u(Tk, hfun, hfun_deriv, start, end)
#Matrix used for checking concavity
mat <- cbind(Tk, fun(Tk), fun_deriv(Tk))
while (size <= n){
#Sample from s(x)
y <- runif(1)
x.temp <- sample_x(uk, y)
#Compute upper and lower value
u.x <- eval_u(x.temp, uk)
l.x <- eval_l(x.temp, Tk, fun)
#Uniform random number to decide wether accept or reject
w=runif(1)
if(w <= exp(l.x - u.x)){
#Accept
result[size] <- x.temp
size <- size + 1
}else{
if(w <= exp(fun(x.temp) - u.x)){
#Accept
result[size] <- x.temp
size <- size + 1
}
#If the density of the point is too small, sample again
if(!is.infinite(fun(x.temp))){
#Reject, Update point
mat <- rbind(mat, c(x.temp, fun(x.temp), fun_deriv(x.temp)))
#Sort by Tk
mat <- mat[order(mat[, 1]), ]
Tk <- mat[, 1]
uk <- generate_u(Tk, fun, fun_deriv, start, end)
##generate h.x and h.dev for checking concavity
######check concavity#####
h.dev <- mat[,3]
if (all(diff(h.dev)<=0)==FALSE){
stop("Not log concave!")
}
}
}
}
return(result)
}
ARS(100, dnorm)
ARS <- function(n, func, start=-Inf, end=Inf, hfun_deriv=NULL, ...){
#####Need to do: check func is concave, normalize?#####
#Check if the input function
if(any(names(formals(func)) == "log")){
hfun <- function(x){
func(x, ..., log=TRUE)
}
}else{
hfun <- function(x){
log(func(x, ...))
}
}
#Get derivative function by Central difference
if(is.null(hfun_deriv)){
h <- 1e-8
hfun_deriv <- function(x){
(hfun(x + h) - hfun(x - h))/(2*h)
}
}
######Question: sorted?#####
#Initial Value
mat <- InitTk(hfun, hfun_deriv, start, end)
Tk <- mat[, 1]
#Set up
result <- rep(0, n)
size <- 1
#Generate u
uk <- generate_u(Tk, hfun, hfun_deriv, start, end)
while (size <= n){
#Sample from s(x)
y <- runif(1)
x.temp <- sample_x(uk, y)
#Compute upper and lower value
u.x <- eval_u(x.temp, uk)
l.x <- eval_l(x.temp, Tk, fun)
#Uniform random number to decide wether accept or reject
w=runif(1)
if(w <= exp(l.x - u.x)){
#Accept
result[size] <- x.temp
size <- size + 1
}else{
if(w <= exp(fun(x.temp) - u.x)){
#Accept
result[size] <- x.temp
size <- size + 1
}
#If the density of the point is too small, sample again
if(!is.infinite(fun(x.temp))){
#Reject, Update point
mat <- rbind(mat, c(x.temp, fun(x.temp), fun_deriv(x.temp)))
#Sort by Tk
mat <- mat[order(mat[, 1]), ]
Tk <- mat[, 1]
uk <- generate_u(Tk, fun, fun_deriv, start, end)
##generate h.x and h.dev for checking concavity
######check concavity#####
h.dev <- mat[,3]
if (all(diff(h.dev)<=0)==FALSE){
stop("Not log concave!")
}
}
}
}
return(result)
}
ARS(100, dnorm)
ARS <- function(n, func, start=-Inf, end=Inf, hfun_deriv=NULL, ...){
#####Need to do: check func is concave, normalize?#####
#Check if the input function
if(any(names(formals(func)) == "log")){
hfun <- function(x){
func(x, ..., log=TRUE)
}
}else{
hfun <- function(x){
log(func(x, ...))
}
}
#Get derivative function by Central difference
if(is.null(hfun_deriv)){
h <- 1e-8
hfun_deriv <- function(x){
(hfun(x + h) - hfun(x - h))/(2*h)
}
}
######Question: sorted?#####
#Initial Value
mat <- InitTk(hfun, hfun_deriv, start, end)
Tk <- mat[, 1]
#Set up
result <- rep(0, n)
size <- 1
#Generate u
uk <- generate_u(Tk, mat[, 2], mat[, 3], start, end)
while (size <= n){
#Sample from s(x)
y <- runif(1)
x.temp <- sample_x(uk, y)
#Compute upper and lower value
u.x <- eval_u(x.temp, uk)
l.x <- eval_l(x.temp, Tk, fun)
#Uniform random number to decide wether accept or reject
w=runif(1)
if(w <= exp(l.x - u.x)){
#Accept
result[size] <- x.temp
size <- size + 1
}else{
if(w <= exp(fun(x.temp) - u.x)){
#Accept
result[size] <- x.temp
size <- size + 1
}
#If the density of the point is too small, sample again
if(!is.infinite(fun(x.temp))){
#Reject, Update point
mat <- rbind(mat, c(x.temp, fun(x.temp), fun_deriv(x.temp)))
#Sort by Tk
mat <- mat[order(mat[, 1]), ]
Tk <- mat[, 1]
uk <- generate_u(Tk, fun, fun_deriv, start, end)
##generate h.x and h.dev for checking concavity
######check concavity#####
h.dev <- mat[,3]
if (all(diff(h.dev)<=0)==FALSE){
stop("Not log concave!")
}
}
}
}
return(result)
}
ARS(100, dnorm)
ARS <- function(n, func, start=-Inf, end=Inf, hfun_deriv=NULL, ...){
#####Need to do: check func is concave, normalize?#####
#Check if the input function
if(any(names(formals(func)) == "log")){
hfun <- function(x){
func(x, ..., log=TRUE)
}
}else{
hfun <- function(x){
log(func(x, ...))
}
}
#Get derivative function by Central difference
if(is.null(hfun_deriv)){
h <- 1e-8
hfun_deriv <- function(x){
(hfun(x + h) - hfun(x - h))/(2*h)
}
}
######Question: sorted?#####
#Initial Value
mat <- InitTk(hfun, hfun_deriv, start, end)
Tk <- mat[, 1]
#Set up
result <- rep(0, n)
size <- 1
#Generate u
uk <- generate_u(Tk, mat[, 2], mat[, 3], start, end)
while (size <= n){
#Sample from s(x)
y <- runif(1)
x.temp <- sample_x(uk, y)
#Compute upper and lower value
u.x <- eval_u(x.temp, uk)
l.x <- eval_l(x.temp, Tk, hfun)
#Uniform random number to decide wether accept or reject
w=runif(1)
if(w <= exp(l.x - u.x)){
#Accept
result[size] <- x.temp
size <- size + 1
}else{
if(w <= exp(hfun(x.temp) - u.x)){
#Accept
result[size] <- x.temp
size <- size + 1
}
#If the density of the point is too small, sample again
if(!is.infinite(hfun(x.temp))){
#Reject, Update point
mat <- rbind(mat, c(x.temp, hfun(x.temp), hfun_deriv(x.temp)))
#Sort by Tk
mat <- mat[order(mat[, 1]), ]
Tk <- mat[, 1]
uk <- generate_u(Tk, mat[, 2], mat[, 3], start, end)
##generate h.x and h.dev for checking concavity
######check concavity#####
h.dev <- mat[, 3]
if (all(diff(h.dev)<=0)==FALSE){
stop("Not log concave!")
}
}
}
}
return(result)
}
ARS(100, dnorm)
ARS(100, dnorm)
ARS(100, dnorm)
ARS(100, dnorm)
rm(list=ls())
InitTk <- function(hfun, hfun_deriv, start, end){
xhfunp <- function(x){
return(c(x, hfun(x), hfun_deriv(x)))
}
m <- 1
m.max <- 500
if ((start == -Inf) & (end == Inf)){
while (1){
mat.temp <- xhfunp(rnorm(1,sd=10))
if (mat.temp[2] != -Inf){
break
}
}
mat.temp.pre <- mat.temp
if (mat.temp[3] < 0){
mat <- mat.temp
while (mat.temp[3] < 0 & m < m.max) {
mat.temp <- xhfunp(mat.temp[1]-2^m)
if (mat.temp[3] < mat.temp.pre[3]){
stop("The input function is NOT Log-concave!")
} else {
mat <- rbind(mat, mat.temp)
mat.temp.pre <- mat.temp
m <- m + 1
}
}
} else if (mat.temp[3] > 0) {
mat <- mat.temp
while (mat.temp[3] > 0 && m < m.max) {
mat.temp <- xhfunp(mat.temp[1]+2^m)
if (mat.temp[3] > mat.temp.pre[3]){
stop("The input function is NOT Log-concave!")
} else {
mat <- rbind(mat, mat.temp)
mat.temp.pre <- mat.temp
m <- m + 1
}
}
}
}  else if ((start == -Inf) && (end != Inf)) {
while (1){
mat.temp <- xhfunp(end - rexp(1, rate=0.1))
if (mat.temp[2] != -Inf){
break
}
}
mat <- mat.temp
while (1){
mat.temp <- xhfunp(end - rexp(1, rate=0.1))
if (mat.temp[2] != -Inf){
mat <- rbind(mat, mat.temp)
break
}
}
mat.temp.pre <- mat.temp
while (mat.temp[3] < 0 & m < m.max) {
mat.temp <- xhfunp(mat.temp[1] - 2^m)
if (mat.temp[3] < mat.temp.pre[3]){
stop("The input function is NOT Log-concave!")
} else {
mat <- rbind(mat, mat.temp)
mat.temp.pre <- mat.temp
m <- m + 1
}
}
} else if ((start != -Inf) & (end == Inf)) {
while (1){
mat.temp <- xhfunp(start + rexp(1, rate=0.01))
if (mat.temp[2] != -Inf){
break
}
}
mat <- mat.temp
while (1){
mat.temp <- xhfunp(start + rexp(1, rate=0.01))
if (mat.temp[2] != -Inf){
mat <- rbind(mat, mat.temp)
break
}
}
mat.temp.pre <- mat.temp
while (mat.temp[3] > 0 & m < m.max) {
mat.temp <- xhfunp(mat.temp[1] + 2^m)
if (mat.temp[3] > mat.temp.pre[3]){
stop("The input function is NOT Log-concave!")
} else {
mat <- rbind(mat, mat.temp)
mat.temp.pre <- mat.temp
m <- m + 1
}
}
}  else {
a <- start + (end-start)/3
b <- end - (end-start)/3
mat <- rbind(xhfunp(a), xhfunp(b))
}
mat <- mat[order(mat[, 1]), ]
return(mat)
}
generate_u <- function(x, hfun.x, hfun_deriv.x, start, end){
k <- length(x)
z <- (hfun.x[-1] - hfun.x[-k] - x[-1]*hfun_deriv.x[-1] + x[-k]*hfun_deriv.x[-k])/(hfun_deriv.x[-k] - hfun_deriv.x[-1])
#Construct upper and lower bound
z <- c(start, z, end)
#Compute slope and intercept
a <- hfun_deriv.x
b <- hfun.x - a*x
out <- list(parameter=cbind(a, b), breaks=z)
out
}
sample_x <- function(mu, y){
## calculate the list of areas ##
z <- mu$breaks
area <- rep(0, length(z)-1)
for (i in 1:length(area)){
# get parameters
a <- mu$parameter[i, 1]
b <- mu$parameter[i, 2]
# compute area
area[i] <- (exp(a*z[i+1]+b)-exp(a*z[i]+b))/a
}
## determine which interval y falls in ##
chosen_area <- y*sum(area)
cum_area <- c(0,cumsum(area))
index <- findInterval(chosen_area,cum_area)
sub_area <- chosen_area-cum_area[index]
## find the corresponding x values ##
x_star <- rep(0,length(y))
for (j in 1:length(index)){
i <- index[j]
a <- mu$parameter[i, 1]
b <- mu$parameter[i, 2]
z_star <- z[i]
area_star <- sub_area[j]
xx_star <- (log(a*area_star+exp(a*z_star+b))-b)/a
x_star[j] <- xx_star
}
return(x_star)
}
eval_u <- function(x.temp, u){
# evalu: evaluate u(x) at temp.x
# Input:
#   temp.x, given x value
#   u, u function parameters
# Output:
#   u.val, u value at temp.x
# Check if temp.x is out of bounds.
if (x.temp < head(u$breaks,n=1) || x.temp > tail(u$breaks,n=1)){
stop("x.temp is out of bound.")
}
ind <- sum(u$breaks <= x.temp)
u.val <- u$parameter[ind,1] * x.temp + u$parameter[ind,2]
return(as.numeric(u.val))
}
eval_l <- function(x1, x, fun){
k <- length(x)
#Grouping
group <- cut(x1, breaks=x, labels=1:(k - 1))
#Check which group the x1 locate
xj <- x[as.numeric(group)]
xjplus <- x[as.numeric(group) + 1]
#Compute value
all <- ((xjplus - x1)*fun(xj) + (x1 - xj)*fun(xjplus))/(xjplus - xj)
all[is.na(all)] <- -Inf
return(all)
}
ARS <- function(n, func, start=-Inf, end=Inf, hfun_deriv=NULL, ...){
#####Need to do: check func is concave, normalize?#####
#Check if the input function
if(any(names(formals(func)) == "log")){
hfun <- function(x){
func(x, ..., log=TRUE)
}
}else{
hfun <- function(x){
log(func(x, ...))
}
}
#Get derivative function by Central difference
if(is.null(hfun_deriv)){
h <- 1e-8
hfun_deriv <- function(x){
(hfun(x + h) - hfun(x - h))/(2*h)
}
}
######Question: sorted?#####
#Initial Value
mat <- InitTk(hfun, hfun_deriv, start, end)
Tk <- mat[, 1]
#Set up
result <- rep(0, n)
size <- 1
#Generate u
uk <- generate_u(Tk, mat[, 2], mat[, 3], start, end)
while (size <= n){
#Sample from s(x)
y <- runif(1)
x.temp <- sample_x(uk, y)
#Compute upper and lower value
u.x <- eval_u(x.temp, uk)
l.x <- eval_l(x.temp, Tk, hfun)
#Uniform random number to decide wether accept or reject
w=runif(1)
if(w <= exp(l.x - u.x)){
#Accept
result[size] <- x.temp
size <- size + 1
}else{
if(w <= exp(hfun(x.temp) - u.x)){
#Accept
result[size] <- x.temp
size <- size + 1
}
#If the density of the point is too small, sample again
if(!is.infinite(hfun(x.temp))){
#Reject, Update point
mat <- rbind(mat, c(x.temp, hfun(x.temp), hfun_deriv(x.temp)))
#Sort by Tk
mat <- mat[order(mat[, 1]), ]
Tk <- mat[, 1]
uk <- generate_u(Tk, mat[, 2], mat[, 3], start, end)
##generate h.x and h.dev for checking concavity
######check concavity#####
h.dev <- mat[, 3]
if (all(diff(h.dev)<=0)==FALSE){
stop("Not log concave!")
}
}
}
}
return(result)
}
ARS(100, dnorm)
library(roxygen2)
roxygenise()
roxygenise()
roxygenise()
build()
library(devtools)
build()
install()
rm(list=ls())
library(ars)
?ARS
?INIT
?InitTk
?ARS
load_all()
library(devtools)
load_all()
? ars
library(testthat)
test_package('ars','main')
library(help=ars)
library(help(ars))
library(help=ars
)
library(help=ars())
load_all()
library(devtools)
library(testthat)
load_all()
test_package('ars','main')
