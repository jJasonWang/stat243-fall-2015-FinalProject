library(ars)
install.packages('Rtools')
library(updateR)
library(installr)
updateR()
install.packages(c("Amelia", "arules", "car", "caret", "coin", "curl", "data.table", "devtools", "evaluate", "fields", "foreach", "formatR", "ggdendro", "git2r", "highr", "installr", "iterators", "jsonlite", "lme4", "maps", "mime", "party", "pls", "quantreg", "randomForest", "rattle", "Rcpp", "RcppArmadillo", "RcppEigen", "readr", "rgl", "rmarkdown", "roxygen2", "rpart.plot", "rstudioapi", "sandwich", "scales", "sp", "spam", "stringi", "testthat", "xml2", "xtable"))
ls
list.files()
library(devtools)
find_rtools()
install.package('Rtools')
install.packages('Rtools')
ks.test(rnorm(100), dnorm)
ks.test(rnorm(100), dnorm)
ks.test(rnorm(100), dnorm)
ks.test(rnorm(100), dnorm)
ks.test(rnorm(100), dnorm)
ks.test(rnorm(100), dnorm)
ks.test(rnorm(100), dnorm)
ks.test(rnorm(100), dnorm)
ks.test(rnorm(100), dnorm)
ks.test(rnorm(100), dnorm)
ks.test(rnorm(100), dnorm, "two-sided")
?ks.test
ks.test(rnorm(100), dnorm, "two.sided")
ks.test(rnorm(100), rnorm)
ks.test(rnorm(100), rnorm(100))
ks.test(rnorm(100), rnorm(100))
ks.test(rnorm(100), rnorm(100))
ks.test(rnorm(100), rnorm(100))
ks.test(rnorm(100), rnorm(100))
ks.test(rnorm(100), rnorm(100))
ks.test(rnorm(100), rnorm(100))
ks.test(rnorm(100), rnorm(100))
ks.test(rnorm(100), rnorm(100))
ks.test(rnorm(100), rnorm(100))
ks.test(rnorm(100), rnorm(100))
ks.test(rnorm(100), rnorm(100))
ks.test(rnorm(100), rnorm(100))
ks.test(rnorm(100), rnorm(100))
ks.test(rnorm(100), rnorm(100))
ks.test(rnorm(100), rnorm(100))
ks.test(rnorm(100), rnorm(100))
ks.test(rnorm(100), rnorm(100))
ks.test(rnorm(100), rnorm(100))
ks.test(rnorm(100), rnorm(100))
ks.test(rnorm(100), rnorm(100))
ks.test(rnorm(100), rnorm(100))
ks.test(rnorm(100), rnorm(100))
ks.test(rnorm(100), rnorm(100))
ks.test(rnorm(100), rnorm(100))
ks.test(rnorm(100), rnorm(100))
ks.test(rnorm(100), rnorm(100))
ks.test(rnorm(1000), rnorm(1000))
ks.test(rnorm(1000), rnorm(1000))
ks.test(rnorm(1000), rnorm(1000))
ks.test(rnorm(1000), rnorm(1000))
ks.test(rnorm(1000), rnorm(1000))
ks.test(rnorm(1000), rnorm(1000))
ks.test(rnorm(1000), rnorm(1000))
ks.test(rnorm(1000), dnorm
)
ks.test(rnorm(1000), dnorm)
ks.test(rnorm(1000), dnorm)
ks.test(rnorm(1000), dnorm)
ks.test(rnorm(1000), dnorm)
ks.test(rnorm(1000), dnorm)
ks.test(rnorm(1000), dnorm)
ks.test(rnorm(1000), "dnorm")
?ks.text
?ks.test
x <- rnorm(50)
y <- runif(30)
# Do x and y come from the same distribution?
ks.test(x, y)
library(devtools)
build()
install()
library(ars)
hello
hello()
?hello
library(ars)
?hekp
?hell
library(roxygen2)
?"roxygen2-package"
?geocode
library(ggmap2)
library(ggmap)
?geocode
?rnorm
?mean
roxygenize()
roxygenize()
roxygenize()
library(devtools)
build()
install()
library(ars)
install()
library(ars)
detach("package:ars", unload=TRUE)
library(ars)
ARS
?ARS
library(help=ars)
library(roxygen2)
roxygenise()
build()
library(devtools)
build()
install()
library(ars)
ARS
?ars
?ARS
InitTk <- function(fun, fun_deriv, start, end){
xfunp <- function(x){
return(c(x, fun(x), fun_deriv(x)))
}
m <- 1
m.max <- 500
if ((start == -Inf) && (end == Inf)) {
while (1){
mat.temp <- xfunp(rnorm(1))
if (mat.temp[2] != -Inf){
break
}
}
mat.temp.pre <- mat.temp
if (mat.temp[3] < 0){
mat <- mat.temp
while (mat.temp[3] < 0 && m < m.max) {
mat.temp <- xfunp(mat.temp[1]-2^m)
if (mat.temp[3] < mat.temp.pre[3]){
stop("NOT Log-concave!!")
} else {
mat <- rbind(mat, mat.temp)
mat.temp.pre <- mat.temp
m <- m + 1
}
}
} else if (mat.temp[3] > 0) {
mat <- mat.temp
while (mat.temp[3] > 0 && m < m.max) {
mat.temp <- xfunp(mat.temp[1]+2^m)
if (mat.temp[3] > mat.temp.pre[3]){
stop("NOT Log-concave!!")
} else {
mat <- rbind(mat, mat.temp)
mat.temp.pre <- mat.temp
m <- m + 1
}
}
}
}  else if ((start == -Inf) && (end != Inf)) {
while (1){
mat.temp <- xfunp(end - rexp(1))
if (mat.temp[2] != -Inf){
break
}
}
mat <- mat.temp
mat.temp.pre <- mat.temp
while (mat.temp[3] < 0 && m < m.max) {
mat.temp <- xfunp(mat.temp[1]-2^m)
if (mat.temp[3] < mat.temp.pre[3]){
stop("NOT Log-concave!!")
} else {
mat <- rbind(mat, mat.temp)
mat.temp.pre <- mat.temp
m <- m + 1
}
}
} else if ((start != -Inf) && (end == Inf)) {
while (1){
mat.temp <- xfunp(start + rexp(1))
if (mat.temp[2] != -Inf){
break
}
}
mat <- mat.temp
mat.temp.pre <- mat.temp
while (mat.temp[3] > 0 && m < m.max) {
mat.temp <- xfunp(mat.temp[1] + 2^m)
if (mat.temp[3] > mat.temp.pre[3]){
stop("NOT Log-concave!!")
} else {
mat <- rbind(mat, mat.temp)
mat.temp.pre <- mat.temp
m <- m + 1
}
}
}  else {
a <- start + (end-start)/3
b <- end - (end-start)/3
mat <- rbind(xfunp(a), xfunp(b))
}
mat <- mat[order(mat[, 1]), ]
return(mat)
}
generate_u <- function(x, fun, fun_deriv, start, end){
k <- length(x)
z <- (fun(x[-1]) - fun(x[-k]) - x[-1]*fun_deriv(x[-1]) + x[-k]*fun_deriv(x[-k]))/(fun_deriv(x[-k]) - fun_deriv(x[-1]))
#Construct upper and lower bound
z <- c(start, z, end)
#Compute slope and intercept
a <- fun_deriv(x)
b <- fun(x) - a*x
out <- list(parameter=cbind(a, b), breaks=z)
out
}
sample_x <- function(mu, y){
## calculate the list of areas ##
z <- mu$breaks
area <- rep(0, length(z)-1)
for (i in 1:length(area)){
# get parameters
a <- mu$parameter[i, 1]
b <- mu$parameter[i, 2]
# compute area
area[i] <- (exp(a*z[i+1]+b)-exp(a*z[i]+b))/a
}
## determine which interval y falls in ##
chosen_area <- y*sum(area)
cum_area <- c(0,cumsum(area))
index <- findInterval(chosen_area,cum_area)
sub_area <- chosen_area-cum_area[index]
## find the corresponding x values ##
x_star <- rep(0,length(y))
for (j in 1:length(index)){
i <- index[j]
a <- mu$parameter[i, 1]
b <- mu$parameter[i, 2]
z_star <- z[i]
area_star <- sub_area[j]
xx_star <- (log(a*area_star+exp(a*z_star+b))-b)/a
x_star[j] <- xx_star
}
return(x_star)
}
eval_u <- function(x.temp, u){
# evalu: evaluate u(x) at temp.x
# Input:
#   temp.x, given x value
#   u, u function parameters
# Output:
#   u.val, u value at temp.x
# Check if temp.x is out of bounds.
if (x.temp < head(u$breaks,n=1) || x.temp > tail(u$breaks,n=1)){
stop("x.temp is out of bound.")
}
ind <- sum(u$breaks <= x.temp)
u.val <- u$parameter[ind,1] * x.temp + u$parameter[ind,2]
return(as.numeric(u.val))
}
eval_l <- function(x1, x, fun){
k <- length(x)
#Grouping
group <- cut(x1, breaks=x, labels=1:(k - 1))
#Check which group the x1 locate
xj <- x[as.numeric(group)]
xjplus <- x[as.numeric(group) + 1]
#Compute value
all <- ((xjplus - x1)*fun(xj) + (x1 - xj)*fun(xjplus))/(xjplus - xj)
all[is.na(all)] <- -Inf
return(all)
}
ARS <- function(n, func, start=-Inf, end=Inf, fun_deriv=NULL, ...){
#####Need to do: check func is concave, normalize?#####
#Check if the input function
if(any(names(formals(func)) == "log")){
fun <- function(x){
func(x, ..., log=TRUE)
}
}else{
fun <- function(x){
log(func(x, ...))
}
}
#Get derivative function by Central difference
if(is.null(fun_deriv)){
h <- 1e-8
fun_deriv <- function(x){
(fun(x + h) - fun(x - h))/(2*h)
}
}
######Question: sorted?#####
#Initial Value
mat <- InitTk(fun, fun_deriv, start, end)
Tk <- mat[1,]
#Set up
result <- rep(0, n)
size <- 1
#Generate u
uk <- generate_u(Tk, fun, fun_deriv, start, end)
#Matrix used for checking concavity
mat <- cbind(Tk, fun(Tk), fun_deriv(Tk))
while (size <= n){
#Sample from s(x)
y <- runif(1)
x.temp <- sample_x(uk, y)
#Compute upper and lower value
u.x <- eval_u(x.temp, uk)
l.x <- eval_l(x.temp, Tk, fun)
#Uniform random number to decide wether accept or reject
w=runif(1)
if(w <= exp(l.x - u.x)){
#Accept
result[size] <- x.temp
size <- size + 1
}else{
if(w <= exp(fun(x.temp) - u.x)){
#Accept
result[size] <- x.temp
size <- size + 1
}
#Reject, Update point
mat <- rbind(mat, c(x.temp, fun(x.temp), fun_deriv(x.temp)))
#Sort by Tk
mat <- mat[order(mat[, 1]), ]
Tk <- mat[, 1]
uk <- generate_u(Tk, fun, fun_deriv, start, end)
##generate h.x and h.dev for checking concavity
######check concavity#####
h.dev <- mat[,3]
if (all(diff(h.dev)<=0)==FALSE){
stop("Not log concave!")
}
}
}
return(result)
}
ARS(100, dnorm, sd=20)
ARS(100, dnorm, sd=100)
ARS(100, dnorm, sd=100)
ARS(100, dnorm, sd=50)
ARS(1000, dnorm, sd=50)
generate_u <- function(x, fun, fun_deriv, start, end){
k <- length(x)
z <- (fun(x[-1]) - fun(x[-k]) - x[-1]*fun_deriv(x[-1]) + x[-k]*fun_deriv(x[-k]))/(fun_deriv(x[-k]) - fun_deriv(x[-1]))
#Construct upper and lower bound
z <- c(start, z, end)
#Compute slope and intercept
a <- fun_deriv(x)
b <- fun(x) - a*x
out <- list(parameter=cbind(a, b), breaks=z)
out
}
start <- -Inf; end <- Inf
fun <- function(x) dnorm(x, log=TRUE)
h <- 1e-8
fun_deriv <- function(x) (fun(x + h) - fun(x - h))/(2*h)
#Initial value
Tk <- c(-1, 1)
u <- generate_u(Tk, fun, fun_deriv, start, end)
#Make plot
x <- seq(-5, 5, by=0.1)
plot(x, fun(x), type="l",
main="Upper bound for N(0, 1)",
xlab="x", ylab="Normal Density in log scale")
abline(a=u$parameter[1, 2], b=u$parameter[1, 1], col="blue", lty=2)
abline(a=u$parameter[2, 2], b=u$parameter[2, 1], col="blue", lty=2)
Tk <- seq(-0.00001, 0.00001, by=1e-8)
u <- generate_u(Tk, fun, fun_deriv, start, end)
u$parameter
table(u$breaks)
which(table(u$breaks) == 2)
