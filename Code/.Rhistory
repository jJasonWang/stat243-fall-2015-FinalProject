optim(0, f, lower=0, upper=3)
Inf == Inf
#Function generate coefficient and breaks
InitTk <- function(f,a = -Inf,b = Inf){
# InitTk: generate the initial Tk set before sampling.
# Input:
#   f, sampling function
#   a, lower bound
#   b, upper bound
#   k, length of Tk
# Output:
#   Tk, a set of x values
# TODO: check the existance of multiple minima? equivalent to log-concave check.
# TODO: log(0) situation
# Construct the minimization function in order to find Mode.
mf <- function(x){
return (-f(x))
#    if (y == 0){
#      stop("Probability density function f(x) of certain x values within the given bounds are zero.
#           It can be caused if the given probability density function approximates very small values as 0.
#           Please narrow the bound input or contact the corresponding authors of the input function.")
#    }
#    return(-log(y))
}
# Calculate Tk
if ((a == -Inf) & (b == Inf)) {
x.init <- 0 # TODO: f(0) might be zero.
opt.res <- optim(x.init, mf, lower=a, upper=b)
Tk <- c(opt.res$par - 1, opt.res$par + 1)
}  else if ((a == -Inf) & (b != Inf)) {
x.init <- b - abs(b)/2
opt.res <- optim(x.init, mf, lower=a, upper=b)
if (opt.res == b){
Tk <- c(opt.res$par - 2, (opt.res$par + b)/2 - 1)
} else {
Tk <- c(opt.res$par - 1, (opt.res$par + b)/2)
}
}  else if ((a != -Inf) & (b == Inf)) {
x.init <- a + abs(a)/2
opt.res <- optim(x.init, mf, lower=a, upper=b)
if (opt.res == a){
Tk <- c((opt.res$par + a)/2 + 1, opt.res$par + 2)
} else {
Tk <- c((opt.res$par + a)/2, opt.res$par + 1)
}
}  else {
x.init <- (a + b)/2
opt.res <- optim(x.init, mf, lower=a, upper=b)
if ((opt.res == a) | (opt.res == b)){
Tk <- c((a + (b-a)/3), (b - (b-a)/3))
} else {
Tk <- c((opt.res$par + a)/2, (opt.res$par + b)/2)
}
}
return(Tk)
}
InitTk(dexp, a=0)
is.finite
is.finite(Inf)
0 == Inf
0 == -Inf
optim(0, f, lower=0, upper=Inf)
optim(0, f, lower=0)
f
optim(0, f, lower=1, upper=3)
optim(0, dnorm, -Inf, 1)
optim(0, dnorm, -Inf, 1, control=list(fnscale=1))
optim(0, dnorm, -Inf, 1, control=list(fnscale=-1))
optim(0, dnorm, lower=-Inf, upper=1, control=list(fnscale=-1))
InitTk <- function(f, a=-Inf, b=Inf){
#fnscale=-1 make it become maximize problem
if(a == -Inf & b == Inf){
v <- optim(0, f, lower=a, upper=b, control=list(fnscale=-1), method="BFGS")$par
c(v - 1, v + 1)
}else if(a == -Inf & b !=Inf){
v <- optim(b - 1, f, lower=a, upper=b, control=list(fnscale=-1), method="BFGS")$par
d <- b - v
c(v - d/2, v + d/2)
}else if(a != -Inf & b == Inf){
v <- optim(a + 1, f, lower=a, upper=b, control=list(fnscale=-1), method="BFGS")$par
d <- v - a
c(v - d/2, v + d/2)
}else if(a != -Inf & b != Inf){
v <- optim((a + b)/2, f, lower=a, upper=b, control=list(fnscale=-1), method="BFGS")$par
d <- (b - a)/4
c(v - d, v + d)
}
}
InitTk(dnorm)
InitTk(dexp, a=0)
InitTk <- function(f, a, b){
# InitTk: generate the initial Tk set before sampling.
# Input:
#   f, sampling function
#   a, lower bound
#   b, upper bound
#   k, length of Tk
# Output:
#   Tk, a set of x values
# TODO: check the existance of multiple minima? equivalent to log-concave check.
# TODO: log(0) situation
# Construct the minimization function in order to find Mode.
mf <- function(x){
return (-f(x))
#    if (y == 0){
#      stop("Probability density function f(x) of certain x values within the given bounds are zero.
#           It can be caused if the given probability density function approximates very small values as 0.
#           Please narrow the bound input or contact the corresponding authors of the input function.")
#    }
#    return(-log(y))
}
# Calculate Tk
if ((a == -Inf) && (b == Inf)) {
x.init <- 0 # TODO: f(0) might be zero.
opt.res <- optim(x.init, mf, method="BFGS", lower=a, upper=b)
Tk <- c(opt.res$par - 1, opt.res$par + 1)
}  else if ((a == -Inf) && (b != Inf)) {
x.init <- b - abs(b)/2
opt.res <- optim(x.init, mf, method="BFGS", lower=a, upper=b)
if (opt.res$par == b){
Tk <- c(opt.res$par - 2, (opt.res$par + b)/2 - 1)
} else {
Tk <- c(opt.res$par - 1, (opt.res$par + b)/2)
}
}  else if ((a != -Inf) && (b == Inf)) {
x.init <- a + abs(a)/2
opt.res <- optim(x.init, mf, method="BFGS", lower=a, upper=b)
if (opt.res$par == a){
Tk <- c((opt.res$par + a)/2 + 1, opt.res$par + 2)
} else {
Tk <- c((opt.res$par + a)/2, opt.res$par + 1)
}
}  else {
x.init <- (a + b)/2
opt.res <- optim(x.init, mf, method="BFGS", lower=a, upper=b)
if ((opt.res$par == a) | opt.res$par == b)){
Tk <- c((a + (b-a)/3), (b - (b-a)/3))
} else {
Tk <- c((opt.res$par + a)/2, (opt.res$par + b)/2)
}
}
return(Tk)
}
generate_u <- function(x, fun, fun_deriv, start, end){
k <- length(x)
z <- (fun(x[-1]) - fun(x[-k]) - x[-1]*fun_deriv(x[-1]) + x[-k]*fun_deriv(x[-k]))/(fun_deriv(x[-k]) - fun_deriv(x[-1]))
#Construct upper and lower bound
z <- c(start, z, end)
#Grouping
group <- cut(x, breaks=z, labels=1:length(x))
#Check which group the x1 locate
xj <- x[as.numeric(group)]
#Compute value, slope and intercept
value <- fun(xj) + (x - xj)*fun_deriv(xj)
a <- fun_deriv(x)
b <- fun(x) - a*x
out <- list(parameter=cbind(a, b), breaks=z)
out
}
sample_x <- function(mu, y){
## calculate the list of areas ##
z <- mu$breaks
area <- rep(0, length(z)-1)
for (i in 1:length(area)){
# get parameters
a <- mu$parameter[i, 1]
b <- mu$parameter[i, 2]
# compute area
area[i] <- integrate(function(x, a, b) exp(a*x + b), z[i], z[i + 1], a=a, b=b)$value
}
## determine which interval y falls in ##
chosen_area <- y*sum(area)
cum_area <- c(0,cumsum(area))
index <- findInterval(chosen_area,cum_area)
sub_area <- chosen_area-cum_area[index]
## find the corresponding x values ##
x_star <- rep(0,length(y))
for (j in 1:length(index)){
i <- index[j]
a <- mu$parameter[i, 1]
b <- mu$parameter[i, 2]
z_star <- z[i]
area_star <- sub_area[j]
xx_star <- (log(a*area_star+exp(a*z_star+b))-b)/a
x_star[j] <- xx_star
}
return(x_star)
}
eval_u <- function(x.temp, u){
# evalu: evaluate u(x) at temp.x
# Input:
#   temp.x, given x value
#   u, u function parameters
# Output:
#   u.val, u value at temp.x
# Check if temp.x is out of bounds.
if (x.temp < head(u$breaks,n=1) || x.temp > tail(u$breaks,n=1)){
stop("x.temp is out of bound.")
}
ind <- sum(u$breaks <= x.temp)
u.val <- u$parameter[ind,1] * x.temp + u$parameter[ind,2]
return(as.numeric(u.val))
}
eval_l <- function(x1, x, fun){
#Grouping
group <- cut(x1, breaks=x, labels=1:(length(x) - 1))
#Check which group the x1 locate
xj <- x[as.numeric(group)]
xjplus <- x[as.numeric(group) + 1]
#Compute value
all <- ((xjplus - x1)*fun(xj) + (x1 - xj)*fun(xjplus))/(xjplus - xj)
all[is.na(all)] <- -Inf
return(all)
}
ARS <- function(n, func, ..., start=-Inf, end=Inf, fun_deriv=NULL){
#####Need to do: check func is concave, normalize?#####
#Take log
fun <- function(x){
log(func(x, ...))
}
#Get derivative function by Central difference
if(is.null(fun_deriv)){
h <- 1e-8
fun_deriv <- function(x){
(fun(x + h) - fun(x - h))/(2*h)
}
}
######Question: sorted?#####
#Initial Value
Tk <- InitTk(func, start, end)
#Set up
result <- rep(0, n)
size <- 1
#Generate u
uk <- generate_u(Tk, fun, fun_deriv, start, end)
while (size <= n){
#Sample from s(x)
y <- runif(1)
x.temp <- sample_x(uk, y)
#Compute upper and lower value
u.x <- eval_u(x.temp, uk)
l.x <- eval_l(x.temp, Tk, fun)
#Uniform random number to decide wether accept or reject
w=runif(1)
if(w <= exp(l.x - u.x)){
#Accept
result[size] <- x.temp
size <- size + 1
}else{
if(w <= exp(fun(x.temp) - u.x)){
#Accept
result[size] <- x.temp
size <- size + 1
}else{
#Reject
#Update point
Tk <- sort(c(Tk, x.temp))
uk <- generate_u(Tk, fun, fun_deriv, start, end)
##generate h.x and h.dev for checking concavity
h.x <- sapply(Tk, func)
h.dev <- sapply(Tk, fun_deriv)
######check concavity#####
}
}
}
return(result)
}
ARS(n=10, dnorm)
ARS(n=10, dnorm, sd=10)
ARS(n=10, dnorm, sd=100)
ARS(n=10, dnorm, sd=1000)
ARS(n=10, dnorm, sd=100)
ARS(n=10, dnorm, sd=100)
ARS(n=10, dexp)
ARS(n=10, dexp)
ARS(n=10, dexp)
ARS(n=10, dexp)
ARS(n=10, dexp)
ARS <- function(n, func, ..., start=-Inf, end=Inf, fun_deriv=NULL){
#####Need to do: check func is concave, normalize?#####
#Take log
fun <- function(x){
log(func(x, ...))
}
#Get derivative function by Central difference
if(is.null(fun_deriv)){
h <- 1e-8
fun_deriv <- function(x){
(fun(x + h) - fun(x - h))/(2*h)
}
}
######Question: sorted?#####
#Initial Value
Tk <- InitTk(fun, start, end)
#Set up
result <- rep(0, n)
size <- 1
#Generate u
uk <- generate_u(Tk, fun, fun_deriv, start, end)
while (size <= n){
#Sample from s(x)
y <- runif(1)
x.temp <- sample_x(uk, y)
#Compute upper and lower value
u.x <- eval_u(x.temp, uk)
l.x <- eval_l(x.temp, Tk, fun)
#Uniform random number to decide wether accept or reject
w=runif(1)
if(w <= exp(l.x - u.x)){
#Accept
result[size] <- x.temp
size <- size + 1
}else{
if(w <= exp(fun(x.temp) - u.x)){
#Accept
result[size] <- x.temp
size <- size + 1
}else{
#Reject
#Update point
Tk <- sort(c(Tk, x.temp))
uk <- generate_u(Tk, fun, fun_deriv, start, end)
##generate h.x and h.dev for checking concavity
h.x <- sapply(Tk, func)
h.dev <- sapply(Tk, fun_deriv)
######check concavity#####
}
}
}
return(result)
}
ARS(n=10, dnorm)
ARS(n=10, dnorm, mean=1)
ARS(n=10, dnorm, mean=2)
ARS(n=10, dnorm, mean=3)
ARS(n=10, dnorm, mean=4)
ARS(n=10, dnorm, mean=5)
ARS(n=10, dnorm, mean=100)
ARS(n=10, dnorm, mean=10)
ARS(n=10, dnorm, mean=11)
ARS(n=10, dnorm, mean=15)
ARS(n=10, dnorm, mean=16)
ARS(n=10, dnorm, mean=17)
ARS(n=10, dnorm, mean=18)
fun <- function(x) {log(dnorm(x, mean=10))}
h <- 1e-8
fun_deriv <- function(x){
(fun(x + h) - fun(x - h))/(2*h)
}
Tk <- InitTk(fun, start, end)
Tk <- InitTk(fun, 0, Inf)
Tk
uk <- generate_u(Tk, fun, fun_deriv, start, end)
Tk
uk <- generate_u(Tk, fun, fun_deriv, 0, Inf)
uk
ARS(n=100, dexp, start = 0)
x <- seq(0, 5, by=0.01)
plot(x, log(dexp(x)))
plot(x, log(dexp(x)), type="l")
InitTk(dexp)
InitTk(dexp, 0)
InitTk
InitTk <- function(f, a, b){
# InitTk: generate the initial Tk set before sampling.
# Input:
#   f, sampling function
#   a, lower bound
#   b, upper bound
#   k, length of Tk
# Output:
#   Tk, a set of x values
# TODO: check the existance of multiple minima? equivalent to log-concave check.
# TODO: log(0) situation
# Construct the minimization function in order to find Mode.
mf <- function(x){
return (-f(x))
#    if (y == 0){
#      stop("Probability density function f(x) of certain x values within the given bounds are zero.
#           It can be caused if the given probability density function approximates very small values as 0.
#           Please narrow the bound input or contact the corresponding authors of the input function.")
#    }
#    return(-log(y))
}
# Calculate Tk
if ((a == -Inf) && (b == Inf)) {
x.init <- 0 # TODO: f(0) might be zero.
opt.res <- optim(x.init, mf, method="BFGS", lower=a, upper=b)
Tk <- c(opt.res$par - 1, opt.res$par + 1)
}  else if ((a == -Inf) && (b != Inf)) {
x.init <- b - abs(b)/2
opt.res <- optim(x.init, mf, method="BFGS", lower=a, upper=b)
if (opt.res$par == b){
Tk <- c(opt.res$par - 2, (opt.res$par + b)/2 - 1)
} else {
Tk <- c(opt.res$par - 1, (opt.res$par + b)/2)
}
}  else if ((a != -Inf) && (b == Inf)) {
x.init <- a + abs(a)/2
opt.res <- optim(x.init, mf, method="BFGS", lower=a, upper=b)
if (opt.res$par == a){
Tk <- c((opt.res$par + a)/2 + 1, opt.res$par + 2)
} else {
Tk <- c((opt.res$par + a)/2, opt.res$par + 1)
}
}  else {
x.init <- (a + b)/2
opt.res <- optim(x.init, mf, method="BFGS", lower=a, upper=b)
if ((opt.res$par == a) | (opt.res$par == b)){
Tk <- c((a + (b-a)/3), (b - (b-a)/3))
} else {
Tk <- c((opt.res$par + a)/2, (opt.res$par + b)/2)
}
}
return(Tk)
}
InitTk(dexp, 0)
InitTk(dexp, 0, Inf)
f
fun_derive
fun_deriv
generate_u(x)
x
fun
fun <- function(x) {log(dexp)}
generate_u(x, fun, fun_deriv, 0, Inf)
rm(list=ls())
source('C:/Users/jason/Desktop/main2.R', echo=TRUE)
ARS(n=100, dexp, start = 0)
ARS(n=100, dexp, start = 0)
hist(ARS(n=100, dexp, start = 0))
hist(ARS(n=100, dexp, start = 0))
hist(ARS(n=100, dexp, start = 0), prob=TRUE)
hist(ARS(n=100, dexp, start = 0), prob=TRUE)
hist(ARS(n=100, dexp, start = 0), prob=TRUE)
hist(ARS(n=100, dexp, start = 0), prob=TRUE)
hist(ARS(n=100, dexp, start = 0), prob=TRUE)
hist(ARS(n=100, dexp, start = 0), prob=TRUE)
hist(ARS(n=100, dexp, start = 0), prob=TRUE)
hist(ARS(n=100, dexp, start = 0), prob=TRUE)
hist(ARS(n=1000, dexp, start = 0), prob=TRUE)
x
x <- seq(0, 5, by=0.1)
plot(x, dexp(x))
hist(ARS(n=1000, dexp, start = 0), prob=TRUE)
lines(x, dexp(x))
lines(x, dexp(x))
hist(ARS(n=1000, dexp, start = 0), prob=TRUE)
hist(ARS(n=1000, dexp, start = 0), prob=TRUE)
hist(ARS(n=1000, dexp, start = 0), prob=TRUE)
hist(ARS(n=1000, dexp, start = 0), prob=TRUE)
hist(ARS(n=1000, dexp, start = 0), prob=TRUE)
hist(ARS(n=1000, dexp, start = 0), prob=TRUE)
hist(ARS(n=1000, dexp, start = 0), prob=TRUE)
hist(ARS(n=1000, dexp, start = 0), prob=TRUE)
lines(x, dexp(x))
hist(ARS(n=1000, dexp, start = 0), prob=TRUE)
hist(ARS(n=1000, dexp, start = 0), prob=TRUE)
hist(ARS(n=1000, dexp, start = 0), prob=TRUE)
hist(ARS(n=1000, dexp, start = 0), prob=TRUE)
hist(ARS(n=1000, dexp, start = 0), prob=TRUE)
hist(ARS(n=1000, dexp, start = 0), prob=TRUE)
hist(ARS(n=1000, dexp, start = 0), prob=TRUE)
hist(ARS(n=1000, dexp, start = 0), prob=TRUE)
hist(ARS(n=1000, dexp, start = 0), prob=TRUE)
hist(ARS(n=1000, dexp, start = 0), prob=TRUE)
hist(ARS(n=1000, dexp, start = 0), prob=TRUE)
hist(ARS(n=1000, dexp, start = 0), prob=TRUE)
hist(ARS(n=1000, dexp, start = 0), prob=TRUE)
hist(ARS(n=1000, dexp, start = 0), prob=TRUE)
hist(ARS(n=1000, dexp, start = 0), prob=TRUE)
hist(ARS(n=1000, dexp, start = 0), prob=TRUE)
hist(ARS(n=1000, dexp, start = 0), prob=TRUE)
hist(ARS(n=1000, dexp, start = 0), prob=TRUE)
hist(ARS(n=1000, dexp, start = 0), prob=TRUE)
hist(ARS(n=1000, dexp, start = 0), prob=TRUE)
hist(ARS(n=1000, dexp, start = 0), prob=TRUE)
hist(ARS(n=1000, dexp, start = 0), prob=TRUE)
hist(ARS(n=1000, dexp, start = 0), prob=TRUE)
hist(ARS(n=1000, dexp, start = 0), prob=TRUE)
hist(ARS(n=1000, dexp, start = 0), prob=TRUE)
hist(ARS(n=1000, dexp, start = 0), prob=TRUE)
hist(ARS(n=1000, dexp, start = 0), prob=TRUE)
hist(ARS(n=1000, dexp, start = 0), prob=TRUE)
hist(ARS(n=1000, dexp, start = 0), prob=TRUE)
hist(ARS(n=1000, dexp, start = 0), prob=TRUE)
hist(ARS(n=1000, dexp, start = 0), prob=TRUE)
hist(ARS(n=1000, dexp, start = 0), prob=TRUE)
hist(ARS(n=1000, dexp, start = 0), prob=TRUE)
hist(ARS(n=1000, dexp, start = 0), prob=TRUE)
ARS(n=10, dnorm)
hist(ARS(n=1000, dexp, start = 0), prob=TRUE)
hist(ARS(n=1000, dexp, start = 0), prob=TRUE)
hist(ARS(n=1000, dexp, start = 0), prob=TRUE)
hist(ARS(n=1000, dexp, start = 0), prob=TRUE)
replicate(100, hist(ARS(n=1000, dexp, start=0)))
ARS(n=10, dnorm, mean=10)
ARS(n=10, dnorm, mean=100)
ARS(n=10, dnorm, mean=10, sd=10)
ARS(n=10, dnorm, sd=100)
source('C:/Users/jason/Desktop/main2.R', echo=TRUE)
ARS(n=100, dexp)
ARS(n=100, dexp)
ARS(n=100, dexp)
ARS(n=100, dexp)
ARS(n=100, dexp)
ARS(n=100, dexp, start=0)
ARS(n=100, dexp, start=0)
ARS(n=100, dexp, start=0)
ARS(n=100, dexp, start=0)
ARS(n=100, dexp, start=0)
ARS(n=100, dexp, start=0)
